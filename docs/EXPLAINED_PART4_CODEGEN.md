# The Complete Compiler Walkthrough - Part 4: Code Generation

**Understanding SPIR-V Generation and OpSelect Predication**

---

## What is Code Generation?

The final stage: convert the type-checked AST into SPIR-V assembly instructions.

**What we have:** Tree structure (AST) representing the program
**What we need:** Linear sequence of SPIR-V instructions

**Challenge:** SPIR-V has strict requirements:
1. Linear SSA only - NO branching (`OpBranch` forbidden!)
2. Constants BEFORE function
3. All variables declared at function start
4. Specific instruction order

**File:** `src/codegen.c` (560 lines)

---

## SPIR-V Basics: What is it?

**SPIR-V** = Standard Portable Intermediate Representation - Vulkan

It's like assembly language, but for GPUs.

**Example SPIR-V:**
```spirv
%1 = OpConstant %t_float 1.0
%2 = OpVariable %t_ptr_func_float Function
OpStore %2 %1
```

**Breakdown:**
- `%1`, `%2` = SSA IDs (like registers)
- `OpConstant` = Create constant
- `OpVariable` = Declare variable
- `OpStore` = Store value in variable

**SSA = Static Single Assignment:**
- Each ID is assigned EXACTLY ONCE
- IDs never change value
- Example: Can't do `%1 = ...; %1 = ...;` ❌

---

## The SPIR-V Module Structure

Every SPIR-V module has this structure:

```spirv
; 1. PROLOGUE (fixed header)
OpCapability Shader
%ext = OpExtInstImport "GLSL.std.450"
OpMemoryModel Logical GLSL450
OpEntryPoint Fragment %main "main" ...
OpExecutionMode %main OriginLowerLeft

; 2. TYPE DECLARATIONS (fixed)
%t_void = OpTypeVoid
%t_float = OpTypeFloat 32
%t_vec4 = OpTypeVector %t_float 4
...

; 3. INTERFACE VARIABLES (fixed - builtins)
%mglsl_ Color = OpVariable %t_ptr_input_vec4 Input
%mglsl_FragColor = OpVariable %t_ptr_output_vec4 Output
...

; 4. CONSTANTS (generated by us!)
%c_float_0 = OpConstant %t_float 0.0
%c_float_1 = OpConstant %t_float 1.0
%100 = OpConstant %t_float 1.5
...

; 5. MAIN FUNCTION (generated by us!)
%main = OpFunction %t_void None %t_fn
%entry = OpLabel

; Variables
%200 = OpVariable %t_ptr_func_float Function
%201 = OpVariable %t_ptr_func_vec4 Function

; Code
%202 = OpConstant %t_float 1.0
OpStore %200 %202
...

OpReturn
OpFunctionEnd
```

**Our job:** Generate sections 4 and 5.

**Fixed parts (sections 1-3):** Provided by a prologue file (we just emit them).

---

## The Constant Pooling Problem

**Challenge:**We don't know what constants we need until we generate the code, but constants must come BEFORE the function!

**Example:**
```c
{
    float x = 1.0;    // Need constant 1.0
    float y = 2.5;    // Need constant 2.5
}
```

**If we generate linearly:**
```spirv
; Start function
%main = OpFunction ...
%entry = OpLabel

; Generate x = 1.0
%100 = OpConstant %t_float 1.0  ← Can't emit here! Too late!
OpStore %x %100
```

**The constant must be BEFORE the function, but we don't know we need it until we're generating the function body!**

### Solution: Memory Stream Buffering

**Key insight:** Generate function body into a MEMORY BUFFER,  then emit constants first, then emit the buffered function.

**Implementation (lines 559-586):**
```c
void generate_code(node *ast, FILE *output) {
    // 1. Create memory stream to buffer function body
    char *func_body = NULL;
    size_t body_size = 0;
    FILE *body_stream = open_memstream(&func_body, &body_size);
    
    // 2. Generate function INTO MEMORY BUFFER
    fprintf(body_stream, "%%entry = OpLabel\n");
    processdecls_allocate(ast->scope.declarations, body_stream);
    process_decls_initialize(ast->scope.declarations, body_stream);
    process_stmts_codegen(ast->scope.statements, body_stream);
    fprintf(body_stream, "OpReturn\n");
    fprintf(body_stream, "OpFunctionEnd\n");
    fclose(body_stream);  // This fills func_body with the generated code
    
    // 3. Now emit in correct order
    emit_prologue(output);                    // 1. Fixed header
    emit_constants(output);                   // 2. Constants (collected during step 2)
    fprintf(output, "%%main = OpFunction ..."); // 3. Function header
    fprintf(output, "%s", func_body);         // 4. Function body (from buffer)
    
    free(func_body);
}
```

**Magic of `open_memstream`:**
- Acts like a file, but writes to memory instead of disk
- `func_body` pointer gets the generated text
- We can write to `body_stream` normally, then access the text via `func_body`

**During function generation, when we need a constant:**
```c
int gen_float_constant(float val, FILE *out) {
    int const_id = gen_id();
    char buf[100];
    sprintf(buf, "%%%-3d = OpConstant %%t_float %f\n", const_id, val);
    add_const(const_id, buf);  // Add to pool (not to 'out'!)
    return const_id;
}
```

**Later, `emit_constants()` emits them:**
```c
void emit_constants(FILE *out) {
    for (entry in const_pool) {
        fprintf(out, "%s", entry->text);  // Emit the OpConstant line
    }
}
```

**Result:** Constants emitted before function, even though we discovered them while generating function!

---

## The Variable Tracking System

**Problem:** We need to remember variable types for correct `OpLoad` instructions.

**Example:**
```c
float x = 1.0;
vec4 y = vec4(1,0,0,1);
```

Later when we use them:
```c
x + 2.0;  // Need: OpLoad %t_float %x_id
y[0];     // Need: OpLoad %t_vec4 %y_id
```

We need to remember: `x` is float, `y` is vec4.

### Variable Entry Structure

**Lines 49-68:**
```c
typedef struct var_entry {
    char *name;          // "x", "y"
    int id;              // SSA ID for the OpVariable
    int type_code;       // FLOAT_T, VEC_T, etc.
    int vec_size;        // 0 for scalar, 1 for vec2, 2 for vec3, 3 for vec4
    struct var_entry *next;
} var_entry;

static var_entry *local_vars = NULL;
```

**Operations:**
```c
// Add variable
void add_local_var(const char *name, int id, int type_code, int vec_size) {
    var_entry *e = malloc(sizeof(var_entry));
    e->name = strdup(name);
    e->id = id;
    e->type_code = type_code;
    e->vec_size = vec_size;
    e->next = local_vars;
    local_vars = e;
}

// Look up variable ID
int lookup_var(const char *name) {
    for (var_entry *e = local_vars; e; e = e->next) {
        if (strcmp(e->name, name) == 0)
            return e->id;
    }
    return -1;  // Not found
}

// Look up variable type
const char* lookup_var_type(const char *name) {
    for (var_entry *e = local_vars; e; e = e->next) {
        if (strcmp(e->name, name) == 0) {
            if (e->vec_size == 0) {
                return "%t_float";  // Scalar
            } else {
                switch (e->vec_size) {
                    case 1: return "%t_vec2";
                    case 2: return "%t_vec3";
                    case 3: return "%t_vec4";
                }
            }
        }
    }
    return "%t_float";  // Default
}
```

---

## SSA ID Allocation

**SSA = Static Single Assignment:** Each value gets a unique ID.

**Implementation (lines 227-229):**
```c
static int next_id = 100;

static int gen_id(void) {
    return next_id++;
}
```

**Usage:**
```c
int var_id = gen_id();  // Get %100
fprintf(out, "%%%-3d = OpVariable ...\n", var_id);

int const_id = gen_id();  // Get %101
fprintf(out, "%%%-3d = OpConstant ...\n", const_id);
```

**Why start at 100?** IDs 1-99 reserved for prologue (types, built-ins, etc.).

**Why never reuse?** SSA requirement - each ID assigned exactly once.

---

## Phase 1: Allocate Variables

**All `OpVariable` instructions must be at function start** (SPIR-V rule).

**Process (lines 237-249):**
```c
void process_decls_allocate(node *decls, FILE *out) {
    node *curr = decls;
    while (curr) {
        node *decl = curr->list.item;
        if (decl) {
            int var_id = gen_id();
            const char *type = get_spirv_type(decl->declaration.type);
            
            fprintf(out, "%%%-3d = OpVariable %%t_ptr_func_%s Function\n",
                    var_id, type_suffix);
            
            add_local_var(decl->declaration.identifier, var_id,
                         decl->declaration.type->type.type_code,
                         decl->declaration.type->type.vec_size);
        }
        curr = curr->list.next;
    }
}
```

**Example output:**
```spirv
%100 = OpVariable %t_ptr_func_float Function  ; float x
%101 = OpVariable %t_ptr_func_vec4 Function   ; vec4 color
```

**What this does:**
1. Walk linked list of declarations
2. For each: allocate SSA ID
3. Emit `OpVariable` instruction
4. Remember (name → ID, type) mapping

---

## Phase 2: Initialize Variables

**Now emit `OpStore` for initializers (lines 251-265):**
```c
void process_decls_initialize(node *decls, FILE *out) {
    node *curr = decls;
    while (curr) {
        node *decl = curr->list.item;
        if (decl && decl->declaration.initializer) {
            int var_id = lookup_var(decl->declaration.identifier);
            int init_id = gen_expression(decl->declaration.initializer, out);
            
            fprintf(out, "OpStore %%%-3d %%%-3d\n", var_id, init_id);
        }
        curr = curr->list.next;
    }
}
```

**Example:**
```c
float x = 1.0;
```

**Generated SPIR-V:**
```spirv
; Phase 1: Allocate
%100 = OpVariable %t_ptr_func_float Function

; Phase 2: Initialize
%101 = OpConstant %t_float 1.0     ; from gen_expression(1.0)
OpStore %100 %101                   ; x = 1.0
```

---

## Expression Generation: The Heart of Codegen

**Function:** `gen_expression()` (lines 267-428)

**Purpose:** Generate SPIR-V for an expression, return the SSA ID of the result.

**Signature:**
```c
static int gen_expression(node *expr, FILE *out);
```

### Example 1: Literal

**Input AST:**
```
FLOAT_LITERAL_NODE(1.5)
```

**Code (lines 272-277):**
```c
case FLOAT_LITERAL_NODE: {
    int const_id = gen_id();
    char buf[100];
    sprintf(buf, "%%%-3d = OpConstant %%t_float %f\n",
            const_id, expr->float_literal.val);
    add_const(const_id, buf);  // Add to constant pool
    return const_id;
}
```

**Result:** Returns `%101` (added to constant pool)

**Later emitted:**
```spirv
%101 = OpConstant %t_float 1.5
```

### Example 2: Variable Reference

**Input AST:**
```
VAR_NODE("x")
```

**Code (lines 271-300):**
```c
case VAR_NODE: {
    const char *name = expr->variable.identifier;
    
    // Check if built-in
    const char *builtin = get_builtin_var(name);
    if (builtin) {
        int result = gen_id();
        fprintf(out, "%%%-3d = OpLoad %%t_vec4 %s\n", result, builtin);
        return result;
    }
    
    // Local variable
    int var_id = lookup_var(name);
    const char *type = lookup_var_type(name);
    int result = gen_id();
    fprintf(out, "%%%-3d = OpLoad %s %%%-3d\n", result, type, var_id);
    return result;
}
```

**Example for `x` (local float):**
```spirv
%102 = OpLoad %t_float %100  ; Load x
```

**Example for `gl_Color` (built-in):**
```spirv
%103 = OpLoad %t_vec4 %mglsl_Color  ; Load gl_Color
```

**Why OpLoad?** Variables are pointers (addresses). To get the value, we **load** from the address.

### Example 3: Binary Operation

**Input AST:**
```
BINARY_EXPR_NODE('+')
  ├─ left: VAR_NODE("x")
  └─ right: FLOAT_LITERAL(2.0)
```

**Code (lines 302-336):**
```c
case BINARY_EXPR_NODE: {
    // Generate left and right operands
    int left_id = gen_expression(expr->binary_expr.left, out);
    int right_id = gen_expression(expr->binary_expr.right, out);
    
    int result = gen_id();
    const char *op_name;
    
    switch (expr->binary_expr.op) {
        case '+': op_name = "OpFAdd"; break;
        case '-': op_name = "OpFSub"; break;
        case '*': op_name = "OpFMul"; break;
        case '/': op_name = "OpFDiv"; break;
        case '<': op_name = "OpFOrdLessThan"; break;
        case '>': op_name = "OpFOrdGreaterThan"; break;
        case EQ: op_name = "OpFOrdEqual"; break;
        case AND: op_name = "OpLogicalAnd"; break;
        case OR: op_name = "OpLogicalOr"; break;
    }
    
    fprintf(out, "%%%-3d = %s %%t_float %%%-3d %%%-3d\n",
            result, op_name, left_id, right_id);
    return result;
}
```

**Generated SPIR-V:**
```spirv
%102 = OpLoad %t_float %100        ; Load x
%103 = OpConstant %t_float 2.0     ; Literal 2.0
%104 = OpFAdd %t_float %102 %103   ; x + 2.0
```

**Returns:** `%104`

**Recursion:** Notice we call `gen_expression` for left and right! This handles nested expressions:
```c
(x + y) * z
```
Generates:
```spirv
%1 = OpLoad %t_float %x
%2 = OpLoad %t_float %y
%3 = OpFAdd %t_float %1 %2    ; x + y
%4 = OpLoad %t_float %z
%5 = OpFMul %t_float %3 %4    ; (x + y) * z
```

### Example 4: Vector Constructor

**Input AST:**
```
CONSTRUCTOR_NODE(vec4)
  arguments: [1.0, 0.5, 0.2, 1.0]
```

**Code (lines 371-383):**
```c
case CONSTRUCTOR_NODE: {
    int result = gen_id();
    const char *type = get_spirv_type(...);  // %t_vec4
    
    fprintf(out, "%%%-3d = OpCompositeConstruct %s", result, type);
    
    // Generate each argument
    node *arg = expr->constructor.arguments;
    while (arg) {
        int arg_id = gen_expression(arg->list.item, out);
        fprintf(out, " %%%-3d", arg_id);
        arg = arg->list.next;
    }
    
    fprintf(out, "\n");
    return result;
}
```

**Generated SPIR-V:**
```spirv
%101 = OpConstant %t_float 1.0
%102 = OpConstant %t_float 0.5
%103 = OpConstant %t_float 0.2
%104 = OpConstant %t_float 1.0
%105 = OpCompositeConstruct %t_vec4 %101 %102 %103 %104
```

**`OpCompositeConstruct`:** Build a composite (vector/structure) from components.

### Example 5: Vector Indexing

**Input AST:**
```
VAR_NODE("color", array_index=0)  ; color[0]
```

**Code (lines 284-298):**
```c
if (expr->variable.is_array) {
    // Load the vector
    int var_id = lookup_var(name);
    const char *type = lookup_var_type(name);  // %t_vec4
    
    int loaded = gen_id();
    fprintf(out, "%%%-3d = OpLoad %s %%%-3d\n", loaded, type, var_id);
    
    // Extract component
    int result = gen_id();
    fprintf(out, "%%%-3d = OpCompositeExtract %%t_float %%%-3d %d\n",
            result, loaded, expr->variable.array_index);
    
    return result;
}
```

**Generated SPIR-V:**
```spirv
%100 = OpLoad %t_vec4 %color_id     ; Load entire vector
%101 = OpCompositeExtract %t_float %100 0  ; Extract component 0
```

**`OpCompositeExtract`:** Pull out a single component from a vector.

### Example 6: Function Call (dp3)

**Input AST:**
```
FUNCTION_NODE(DP3)
  arguments: [VAR("a"), VAR("b")]
```

**Code (lines 384-410):**
```c
case FUNCTION_NODE: {
    if (expr->function.func_id == DP3) {
        node *arg1 = expr->function.arguments->list.item;
        node *arg2 = expr->function.arguments->list.next->list.item;
        
        int a1 = gen_expression(arg1, out);
        int a2 = gen_expression(arg2, out);
        
        int result = gen_id();
        fprintf(out, "%%%-3d = OpExtInst %%t_float %%ext Dot %%%-3d %%%-3d\n",
                result, a1, a2);
        return result;
    }
    
    if (expr->function.func_id == RSQ) {
        node *arg = expr->function.arguments->list.item;
        int a = gen_expression(arg, out);
        
        int result = gen_id();
        fprintf(out, "%%%-3d = OpExtInst %%t_float %%ext InverseSqrt %%%-3d\n",
                result, a);
        return result;
    }
}
```

**Generated SPIR-V (for dp3):**
```spirv
%100 = OpLoad %t_vec3 %a
%101 = OpLoad %t_vec3 %b
%102 = OpExtInst %t_float %ext Dot %100 %101
```

**`OpExtInst`:** Call an extended instruction from GLSL.std.450 library.
- `Dot` = dot product (instruction 4)
- `InverseSqrt` = 1/sqrt(x) (instruction 32)

---

## Statement Generation

### Assignment Statement

**Input AST:**
```
ASSIGNMENT_NODE
  ├─ variable: VAR("x")
  └─ expr: FLOAT_LITERAL(3.0)
```

**Code (simplified from lines 437-492):**
```c
case ASSIGNMENT_NODE: {
    const char *var_name = stmt->assignment. variable->variable.identifier;
    
    // Generate the expression value
    int rhs_id = gen_expression(stmt->assignment.expr, out);
    
    // Check if it's indexed assignment (x[0] = value)
    if (stmt->assignment.variable->variable.is_array) {
        // Special handling (see next section)
    } else {
        // Simple assignment
        const char *builtin = get_builtin_var(var_name);
        if (builtin) {
            fprintf(out, "OpStore %s %%%-3d\n", builtin, rhs_id);
        } else {
            int var_id = lookup_var(var_name);
            fprintf(out, "OpStore %%%-3d %%%-3d\n", var_id, rhs_id);
        }
    }
}
```

**Generated SPIR-V:**
```spirv
%100 = OpConstant %t_float 3.0    ; from gen_expression(3.0)
OpStore %x_id %100                 ; x = 3.0
```

### Indexed Assignment (The Tricky One!)

**Input:**
```c
color[0] = 1.0;
```

**Problem:** SPIR-V doesn't have "store to index" instruction!

**Solution:** Load entire vector, insert new component, store back

**Code (lines 441-459):**
```c
if (stmt->assignment.variable->variable.is_array) {
    int index = stmt->assignment.variable->variable.array_index;
    int var_id = lookup_var(var_name);
    const char *var_type = lookup_var_type(var_name);  // %t_vec4
    
    // 1. Load entire vector
    int loaded = gen_id();
    fprintf(out, "%%%-3d = OpLoad %s %%%-3d\n", loaded, var_type, var_id);
    
    // 2. Insert new component
    int updated = gen_id();
    fprintf(out, "%%%-3d = OpCompositeInsert %s %%%-3d %%%-3d %d\n",
            updated, var_type, rhs_id, loaded, index);
    
    // 3. Store modified vector back
    fprintf(out, "OpStore %%%-3d %%%-3d\n", var_id, updated);
}
```

**Generated SPIR-V:**
```spirv
%101 = OpConstant %t_float 1.0              ; The value 1.0
%102 = OpLoad %t_vec4 %color_id             ; Load [r, g, b, a]
%103 = OpCompositeInsert %t_vec4 %101 %102 0  ; Insert 1.0 at index 0
OpStore %color_id %103                       ; Store back
```

**`OpCompositeInsert`:** Create new vector with component replaced.

**Why 3 steps?** SSA = values are immutable. Can't modify in-place. Must create new vector.

---

## The Critical Feature: OpSelect Predication

**Challenge:** If statements use branching, but SPIR-V spec forbids `OpBranch`!

**Traditional (forbidden) approach:**
```spirv
%cond = OpFOrdLessThan %t_bool %x %y
OpSelectionMerge %merge None
OpBranchConditional %cond %then %else    ← FORBIDDEN!

%then = OpLabel
  ...
  OpBranch %merge

%else = OpLabel
  ...
  OpBranch %merge

%merge = OpLabel
```

**Our approach: OpSelect predication**

### The OpSelect Instruction

**Syntax:**
```spirv
%result = OpSelect %type %condition %true_value %false_value
```

**Meaning:** If condition is true, result = true_value; else result = false_value

**Example:**
```c
if (x < y)
    z = 10.0;
else
    z = 20.0;
```

**Generated:**
```spirv
%cond = OpFOrdLessThan %t_bool %x %y
%val_true = OpConstant %t_float 10.0
%val_false = OpConstant %t_float 20.0
%result = OpSelect %t_float %cond %val_true %val_false
OpStore %z %result
```

**Key insight:** BOTH branches are evaluated, then one is selected!

### Implementation (lines 494-527)

**Code:**
```c
case IF_STMT_NODE: {
    // Generate condition
    int cond_id = en_expression(stmt->if_stmt.condition, out);
    
    // Must be simple assignment in both branches
    node *then_stmt = stmt->if_stmt.then_stmt;
    node *else_stmt = stmt->if_stmt.else_stmt;
    
    if (then_stmt->kind == ASSIGNMENT_NODE) {
        const char *var_name = then_stmt->assignment.variable->variable.identifier;
        
        // Generate then value
        int then_val = gen_expression(then_stmt->assignment.expr, out);
        
        // Generate else value (or current variable value if no else)
        int else_val;
        if (else_stmt && else_stmt->kind == ASSIGNMENT_NODE) {
            else_val = gen_expression(else_stmt->assignment.expr, out);
        } else {
            // No else branch - keep current value
            int var_id = lookup_var(var_name);
            const char *type = lookup_var_type(var_name);
            else_val = gen_id();
            fprintf(out, "%%%-3d = OpLoad %s %%%-3d\n", else_val, type, var_id);
        }
        
        // Select based on condition
        const char *type = lookup_var_type(var_name);
        int result = gen_id();
        fprintf(out, "%%%-3d = OpSelect %s %%%-3d %%%-3d %%%-3d\n",
                result, type, cond_id, then_val, else_val);
        
        // Store result
        const char *builtin = get_builtin_var(var_name);
        if (builtin) {
            fprintf(out, "OpStore %s %%%-3d\n", builtin, result);
        } else {
            int var_id = lookup_var(var_name);
            fprintf(out, "OpStore %%%-3d %%%-3d\n", var_id, result);
        }
    }
}
```

### Complete Example

**Input code:**
```c
if (x < 2.0)
    y = 10.0;
else
    y = 20.0;
```

**Generated SPIR-V:**
```spirv
; Evaluate condition
%100 = OpLoad %t_float %x
%101 = OpConstant %t_float 2.0
%102 = OpFOrdLessThan %t_bool %100 %101

; Evaluate BOTH branch values
%103 = OpConstant %t_float 10.0    ; then value
%104 = OpConstant %t_float 20.0    ; else value

; Select based on condition
%105 = OpSelect %t_float %102 %103 %104

; Store result
OpStore %y %105
```

**Linear flow!** No `OpLabel`, no `OpBranch`, no phi nodes.

### Why This Works

**Spec requirement:** Linear SSA only

**OpSelect advantages:**
1. No branching instructions
2. No phi nodes (needed to merge control flow)
3. No labels (except %entry)
4. Simpler to generate and validate

**Tradeoff:** Both branches evaluated even if only one is needed  
**Example:** If we always know x < 2.0, we still compute 10.0 AND 20.0, then select 10.0

**Why acceptable?** GPU parallelism means evaluating both is fast, and code is simpler!

### Handling Scopes with Multiple Statements

**Problem:**
```c
if (x < 2.0) {
    y = 10.0;
    z = 20.0;  // Multiple statements!
}
```

**Our implementation warns:**
```
warning - complex if/else scopes with predication
```

**Why?** Multiple assignments need multiple OpSelect instructions, which we implement in a simplified way.

**Proper handling** would require:
1. Generate each assignment's then-value
2. Generate each assignment's else-value
3. OpSelect for each variable

Our code handles this but emits a warning to indicate it's using predication for multi-statement blocks.

---

## Complete Example: Full Program Generation

**Input code:**
```c
{
    float x = 1.0;
    if (x < 2.0) {
        x = 3.0;
    }
    gl_FragColor = vec4(x, x, x, 1.0);
}
```

**Generated SPIR-V (simplified):**

```spirv
; ===== PROLOGUE (fixed) =====
OpCapability Shader
%ext = OpExtInstImport "GLSL.std.450"
OpMemoryModel Logical GLSL450
...
%t_float = OpTypeFloat 32
%t_vec4 = OpTypeVector %t_float 4
...
%mglsl_FragColor = OpVariable %t_ptr_output_vec4 Output

; ===== CONSTANTS (generated) =====
%c_float_0 = OpConstant %t_float 0.0
%c_float_1 = OpConstant %t_float 1.0
%100 = OpConstant %t_float 1.0
%101 = OpConstant %t_float 2.0
%102 = OpConstant %t_float 3.0

; ===== FUNCTION (generated) =====
%main = OpFunction %t_void None %t_fn
%entry = OpLabel

; Phase 1: Allocate
%200 = OpVariable %t_ptr_func_float Function  ; x

; Phase 2: Initialize
OpStore %200 %100  ; x = 1.0

; Statements
; if (x < 2.0) { x = 3.0; }
%201 = OpLoad %t_float %200          ; Load x
%202 = OpFOrdLessThan %t_bool %201 %101  ; x < 2.0
%203 = OpLoad %t_float %200          ; Current x (for else)
%204 = OpSelect %t_float %202 %102 %203  ; Select 3.0 or current x
OpStore %200 %204                     ; Store result

; gl_FragColor = vec4(x, x, x, 1.0)
%205 = OpLoad %t_float %200          ; Load x
%206 = OpCompositeConstruct %t_vec4 %205 %205 %205 %c_float_1
OpStore %mglsl_FragColor %206

OpReturn
OpFunctionEnd
```

---

## Summary: Code Generation (codegen.c)

**Purpose:** Convert AST to SPIR-V assembly

**Input:** Type-checked AST

**Output:** SPIR-V assembly text

**Key Features:**

1. **Constant Pooling**
   - Buffer function body in memory
   - Collect constants during generation
   - Emit constants before function

2. **Variable Tracking**
   - Remember (name → ID, type) mappings
   - Needed for correct OpLoad types

3. **SSA ID Allocation**
   - Monotonic counter starting at 100
   - Each value gets unique ID

4. **OpSelect Predication** ⭐
   - ALL conditionals use OpSelect
   - No branching instructions
   - Linear SSA flow

5. **Indexed Assignment**
   - Load → OpCompositeInsert → Store
   - Handles `v[i] = value`

**Three Phases:**
1. Allocate variables (OpVariable)
2. Initialize variables (OpStore)
3. Generate statements

**Expression Generation:**
- Recursive for nested expressions
- Returns SSA ID of result
- Handles: literals, variables, binary ops, constructors, function calls, indexing

**Statement Generation:**
- Assignments: OpStore
-If/else: OpSelect
- Scopes: Recursive generation

**SPIR-V Module Structure:**
```
Prologue (fixed)
  ↓
Constants (generated, pooled)
  ↓
Function header
  ↓
Variables (allocated)
  ↓
Initialization (stores)
  ↓
Statements (generated)
  ↓
Return
```

**Critical Design Decision: OpSelect vs Branching**
- **Why:** Spec forbids OpBranch, OpPhi
- **How:** Evaluate both branches, select result
- **Trade-off:** Extra computation, but simpler code and spec-compliant

---

**Continue to Part 5 for Complete Examples and Design Decisions...**
